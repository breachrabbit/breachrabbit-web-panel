import { mkdir, symlink, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import { NextRequest, NextResponse } from 'next/server';
import {
  DOMAIN_PATTERN,
  DOMAIN_ROOT,
  NGINX_ENABLED_ROOT,
  NGINX_RELOAD_COMMAND,
  PANEL_CERTBOT_EMAIL,
  PANEL_TARGET_URL,
  SITE_ROOT,
  SYSTEM_CHANGES_ALLOWED,
  normalizeDomain
} from '@/app/lib/panel-config';
import { upsertDomainRegistry } from '@/app/lib/domain-registry';
import { runSystemCommand } from '@/app/lib/system-command';

export async function POST(request: NextRequest) {
  const body = (await request.json().catch(() => null)) as
    | {
        domain?: string;
        createDemoSite?: boolean;
        bindToPanel?: boolean;
        issueCertificate?: boolean;
      }
    | null;

  const domain = normalizeDomain(body?.domain ?? '');
  const createDemoSite = body?.createDemoSite !== false;
  const bindToPanel = body?.bindToPanel === true;
  const issueCertificate = body?.issueCertificate === true;

  if (!domain || !DOMAIN_PATTERN.test(domain)) {
    return NextResponse.json(
      {
        status: 'error',
        message: 'Invalid domain format. Expected value like example.com.'
      },
      { status: 400 }
    );
  }

  const domainConfigPath = join(DOMAIN_ROOT, `${domain}.conf`);
  const enabledConfigPath = join(NGINX_ENABLED_ROOT, `${domain}.conf`);
  const sitePath = join(SITE_ROOT, domain);
  const siteIndexPath = join(sitePath, 'index.html');

  const config = bindToPanel
    ? `server {
  listen 80;
  server_name ${domain};

  include /etc/nginx/snippets/adminer.conf;
  include /etc/nginx/snippets/filebrowser.conf;

  location / {
    proxy_pass ${PANEL_TARGET_URL};
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_cache_bypass $http_upgrade;
  }
}
`
    : `server {
  listen 80;
  server_name ${domain};

  root ${sitePath};
  index index.html;

  location / {
    try_files $uri $uri/ =404;
  }
}
`;

  const demoPage = `<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>${domain}</title>
  </head>
  <body>
    <h1>${domain} is online</h1>
    <p>Generated by BreachRabbit panel domain wizard.</p>
  </body>
</html>
`;

  const plannedFiles = createDemoSite
    ? [domainConfigPath, enabledConfigPath, siteIndexPath]
    : [domainConfigPath, enabledConfigPath];

  if (!SYSTEM_CHANGES_ALLOWED) {
    await upsertDomainRegistry({
      domain,
      attachedToPanel: bindToPanel,
      demoSite: createDemoSite,
      certStatus: issueCertificate ? 'pending' : 'none',
      certIssuedAt: null,
      certExpiresAt: null,
      certProvider: issueCertificate ? 'letsencrypt' : 'n/a',
      lastUpdatedAt: new Date().toISOString()
    });

    return NextResponse.json({
      status: 'dry-run',
      message:
        'System actions are disabled. Set PANEL_ALLOW_SYSTEM_CHANGES=true to create domain files and issue certificates.',
      domain,
      files: plannedFiles
    });
  }

  await mkdir(DOMAIN_ROOT, { recursive: true });
  await mkdir(NGINX_ENABLED_ROOT, { recursive: true });
  await writeFile(domainConfigPath, config, 'utf8');

  try {
    await symlink(domainConfigPath, enabledConfigPath);
  } catch {
    // Ignore if symlink exists or cannot be created due to permissions.
  }

  if (createDemoSite) {
    await mkdir(sitePath, { recursive: true });
    await writeFile(siteIndexPath, demoPage, 'utf8');
  }

  try {
    await runSystemCommand(NGINX_RELOAD_COMMAND);
  } catch (error) {
    return NextResponse.json(
      {
        status: 'error',
        message: error instanceof Error ? error.message : 'Failed to reload Nginx after domain creation'
      },
      { status: 500 }
    );
  }

  let certStatus: 'active' | 'failed' | 'none' = 'none';
  let certIssuedAt: string | null = null;
  let certExpiresAt: string | null = null;

  if (issueCertificate) {
    try {
      await runSystemCommand(
        `certbot --nginx -d ${domain} --non-interactive --agree-tos --redirect -m ${PANEL_CERTBOT_EMAIL}`,
        180_000
      );

      certStatus = 'active';
      certIssuedAt = new Date().toISOString();
      certExpiresAt = new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString();
    } catch {
      certStatus = 'failed';
    }
  }

  await upsertDomainRegistry({
    domain,
    attachedToPanel: bindToPanel,
    demoSite: createDemoSite,
    certStatus,
    certIssuedAt,
    certExpiresAt,
    certProvider: issueCertificate ? 'letsencrypt' : 'n/a',
    lastUpdatedAt: new Date().toISOString()
  });

  return NextResponse.json({
    status: 'ok',
    message: bindToPanel
      ? 'Domain created and attached to panel.'
      : 'Domain config created successfully.',
    domain,
    files: plannedFiles,
    certificate: {
      status: certStatus,
      issuedAt: certIssuedAt,
      expiresAt: certExpiresAt
    }
  });
}
